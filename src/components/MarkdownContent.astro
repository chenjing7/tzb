---
import { marked } from 'marked';
import '../styles/markdownShared.css';

interface Props {
  content: string; // Raw markdown content
}

const { content } = Astro.props;

// Custom preprocessing for HoverChart tags
let processedContent = content;
// Replace HoverChart tags with a placeholder that won't be affected by markdown parsing
const hoverChartRegex = /<HoverChart chartKey="([^"]+)">([^<]+)<\/HoverChart>/gi;
const hoverCharts: Array<{key: string, value: string}> = [];

processedContent = processedContent.replace(hoverChartRegex, (match, chartKey, value) => {
  const id = `hover-chart-${hoverCharts.length}`;
  hoverCharts.push({key: chartKey, value: value});
  return `<span id="${id}" class="hover-chart-placeholder">${value}</span>`;
});

// Parse the markdown to HTML
const html = await marked.parse(processedContent);
---

<div class="markdown-content prose prose-slate max-w-none" id="markdown-container">
  <div id="markdown-content" set:html={html} />
</div>

<script define:vars={{ hoverCharts }}>
  // Initialize hover charts on DOM load
  document.addEventListener('DOMContentLoaded', () => {
    enhanceMarkdownTables();
    processHoverCharts();
  });
  
  // Define hasDataLabelsPlugin at script scope so it's accessible to all functions
  let hasDataLabelsPlugin = false;
  
  // Track chart instances to destroy them before reuse
  const chartInstances = {};
  
  /**
   * Process HoverChart elements that were preprocessed server-side
   */
  function processHoverCharts() {
    // First, load Popper.js as it's a dependency for tippy.js
    loadScript('https://unpkg.com/@popperjs/core@2')
      .then(() => {
        // Then load tippy.js and its CSS
        return Promise.all([
          loadScript('https://unpkg.com/tippy.js@6'),
          loadCSS('https://unpkg.com/tippy.js@6/dist/tippy.css')
        ]);
      })
      .then(() => {
        // Finally load Chart.js
        return loadScript('https://cdn.jsdelivr.net/npm/chart.js');
      })
      .then(() => {
        // Load Chart.js datalabels plugin
        return loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0');
      })
      .then(() => {
        // Once all libraries are loaded, initialize charts
        initializeCharts();
      })
      .catch(error => {
        console.error('Failed to load dependencies:', error);
        // Try with alternative CDN sources as fallback
        console.log('Trying fallback sources...');
        
        // Fallback loading with different CDNs
        loadScript('https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.7/dist/umd/popper.min.js')
          .then(() => Promise.all([
            loadScript('https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.umd.min.js'),
            loadCSS('https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/dist/tippy.css')
          ]))
          .then(() => loadScript('https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js'))
          .then(() => loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0'))
          .then(() => {
            initializeCharts();
          })
          .catch(fallbackError => {
            console.error('Fallback loading also failed:', fallbackError);
          });
      });
  }
  
  function loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.async = true;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
      document.head.appendChild(script);
    });
  }
  
  function loadCSS(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.onload = () => resolve();
      link.onerror = () => reject(new Error(`Failed to load CSS: ${url}`));
      document.head.appendChild(link);
    });
  }
  
  function initializeCharts() {
    // First check if the required libraries are loaded
    if (typeof tippy === 'undefined' || typeof Chart === 'undefined') {
      console.error('Required libraries not loaded. Retrying in 500ms...');
      setTimeout(initializeCharts, 500);
      return;
    }
    
    // Check if ChartDataLabels plugin is loaded
    hasDataLabelsPlugin = typeof ChartDataLabels !== 'undefined';
    if (!hasDataLabelsPlugin) {
      console.warn('ChartDataLabels plugin not loaded. Charts will not show data labels.');
    }
    
    // Process all stored hover charts
    hoverCharts.forEach((chart, index) => {
      const elementId = `hover-chart-${index}`;
      const element = document.getElementById(elementId);
      
      if (!element) {
        console.error('Hover chart element not found:', elementId);
        return;
      }
      
      // Update the element with proper attributes
      element.setAttribute('data-chart-key', chart.key);
      element.classList.add('hover-chart', 'hover-chart-text');
      
      console.log('Setting up hover chart:', chart.key, chart.value);
      
      try {
        // Initialize tippy with error handling
        tippy(element, {
          content: `<div class="chart-tooltip"><canvas id="chart-${chart.key}"></canvas></div>`,
          allowHTML: true,
          interactive: true,
          appendTo: document.body,
          trigger: 'mouseenter focus',
          placement: 'top',
          arrow: true,
          theme: 'light',
          maxWidth: 'none', // Allow the tooltip to size based on content
          onShow(instance) {
            console.log('Tooltip shown, creating chart:', chart.key);
            
            // Fetch data to determine appropriate size
            fetch(`/tzb/data/${chart.key}.json`)
              .then(response => response.json())
              .then(data => {
                if (!data[chart.key]) return;
                
                const chartData = data[chart.key];
                const dataPoints = chartData.length;
                
                // Calculate appropriate dimensions based on data points
                let tooltipWidth = Math.max(350, dataPoints * 70);
                let tooltipHeight = Math.min(220, 180 + (dataPoints > 5 ? 20 : 0));
                
                // Handle very large datasets
                if (dataPoints > 10) {
                  tooltipWidth = Math.min(800, tooltipWidth); // Cap at 800px
                }
                
                // Adjust for mobile screens
                if (window.innerWidth < 768) {
                  tooltipWidth = Math.min(window.innerWidth - 40, tooltipWidth);
                  tooltipHeight = Math.min(200, tooltipWidth * 0.55);
                }
                
                // Apply the calculated dimensions
                const tooltipContent = instance.popper.querySelector('.chart-tooltip');
                if (tooltipContent) {
                  tooltipContent.style.width = `${tooltipWidth}px`;
                  tooltipContent.style.height = `${tooltipHeight}px`;
                }
                
                // Create chart after setting dimensions
                setTimeout(() => {
                  createChart(chart.key, `chart-${chart.key}`);
                }, 10);
              })
              .catch(error => {
                console.error('Error fetching data for tooltip sizing:', error);
                // Fallback to creating chart with default size
                setTimeout(() => {
                  createChart(chart.key, `chart-${chart.key}`);
                }, 10);
              });
          }
        });
      } catch (error) {
        console.error('Error initializing tippy for chart:', chart.key, error);
      }
    });
  }
  
  /**
   * Initialize and enhance markdown tables after the content is loaded
   */
  function enhanceMarkdownTables() {
    const container = document.getElementById('markdown-container');
    if (!container) return;
    
    // Find all tables in the markdown content
    const tables = container.querySelectorAll('table');
    
    tables.forEach((table, index) => {
      // Ensure table has proper styling by adding classes
      table.classList.add('markdown-table');
      
      // Create wrapper elements
      const tableContainer = document.createElement('div');
      tableContainer.className = 'table-container';
      tableContainer.dataset.tableId = `table-${index}`;
      
      // Determine if it's a large table by counting columns or checking width
      const headerRow = table.querySelector('thead tr');
      const columnCount = headerRow ? headerRow.children.length : 0;
      const isLargeTable = columnCount > 7;
      
      // For large tables, add special handling
      if (isLargeTable) {
        tableContainer.classList.add('large-table');
        
        // Create "View full table" button
        const viewButton = document.createElement('button');
        viewButton.className = 'view-full-table';
        viewButton.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon">
            <path d="M15 3h6v6"></path>
            <path d="M9 21H3v-6"></path>
            <path d="M21 3l-7 7"></path>
            <path d="M3 21l7-7"></path>
          </svg>
          查看完整表格
        `;
        viewButton.dataset.viewTable = '';
        
        // Add elements to DOM
        table.parentNode?.insertBefore(tableContainer, table);
        tableContainer.appendChild(table);
        tableContainer.appendChild(viewButton);
        
        // Create modal for the table
        createTableModal(table, index);
        
        // Add click event for the button
        viewButton.addEventListener('click', () => {
          const modal = document.querySelector(`[data-modal-id="modal-${index}"]`);
          if (modal) {
            openModal(modal);
          }
        });
      } else {
        // For regular tables, just add the container
        table.parentNode?.insertBefore(tableContainer, table);
        tableContainer.appendChild(table);
      }
    });
    
    // Add event listeners for modal close buttons
    document.querySelectorAll('[data-close-modal]').forEach(button => {
      button.addEventListener('click', () => {
        const modal = button.closest('.table-modal-overlay');
        if (modal) {
          closeModal(modal);
        }
      });
    });
    
    // Close modal when clicking outside
    document.querySelectorAll('.table-modal-overlay').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal(modal);
        }
      });
    });
    
    // Close modal with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const openModal = document.querySelector('.table-modal-overlay.active');
        if (openModal) {
          closeModal(openModal);
        }
      }
    });
  }
  
  /**
   * Create a modal for displaying a table in full view
   */
  function createTableModal(table, index) {
    // Create modal elements
    const modalOverlay = document.createElement('div');
    modalOverlay.className = 'table-modal-overlay';
    modalOverlay.dataset.modalId = `modal-${index}`;
    
    const modal = document.createElement('div');
    modal.className = 'table-modal';
    
    const modalHeader = document.createElement('div');
    modalHeader.className = 'table-modal-header';
    
    const modalTitle = document.createElement('h3');
    modalTitle.className = 'table-modal-title';
    modalTitle.textContent = '完整表格';
    
    const closeButton = document.createElement('button');
    closeButton.className = 'table-modal-close';
    closeButton.innerHTML = '&times;';
    closeButton.dataset.closeModal = '';
    
    const modalContent = document.createElement('div');
    modalContent.className = 'table-modal-content';
    
    // Clone the table for the modal
    const tableClone = table.cloneNode(true);
    
    // Assemble the modal
    modalHeader.appendChild(modalTitle);
    modalHeader.appendChild(closeButton);
    modalContent.appendChild(tableClone);
    modal.appendChild(modalHeader);
    modal.appendChild(modalContent);
    modalOverlay.appendChild(modal);
    
    // Add to the document
    document.body.appendChild(modalOverlay);
  }
  
  /**
   * Open a table modal
   */
  function openModal(modal) {
    modal.classList.add('active');
    setTimeout(() => {
      const modalContent = modal.querySelector('.table-modal');
      if (modalContent) {
        modalContent.classList.add('active');
      }
    }, 10);
    document.body.style.overflow = 'hidden';
  }
  
  /**
   * Close a table modal
   */
  function closeModal(modal) {
    const modalContent = modal.querySelector('.table-modal');
    if (modalContent) {
      modalContent.classList.remove('active');
    }
    setTimeout(() => {
      modal.classList.remove('active');
      document.body.style.overflow = '';
    }, 300);
  }
  
  /**
   * Create chart with data from the specified JSON file
   */
  async function createChart(chartKey, canvasId) {
    try {
      // Destroy existing chart instance if it exists
      if (chartInstances[canvasId]) {
        chartInstances[canvasId].destroy();
        delete chartInstances[canvasId];
      }
      
      // Fetch chart data
      const response = await fetch(`/tzb/data/${chartKey}.json`);
      console.log('Fetching data from:', `/tzb/data/${chartKey}.json`);
      const data = await response.json();
      console.log('Fetched data:', data);
      
      if (!data[chartKey]) {
        console.error(`No data found for chart key: ${chartKey}`);
        return;
      }
      
      const chartData = data[chartKey];
      const canvas = document.getElementById(canvasId);
      if (!canvas) {
        console.error('Canvas element not found:', canvasId);
        return;
      }
      console.log('Creating chart with data:', chartData);
      
      // Determine best padding based on data size
      const dataPoints = chartData.length;
      const isMobile = window.innerWidth < 768;
      
      // Adaptive padding based on data points and screen size
      const padding = {
        top: isMobile ? 15 : 20,
        right: Math.min(20 + (dataPoints > 5 ? 10 : 0), 30),
        left: isMobile ? 5 : 10,
        bottom: 5
      };
      
      // Adjust point styles based on data quantity
      const pointRadius = dataPoints > 8 ? 3 : 4;
      const pointHoverRadius = dataPoints > 8 ? 5 : 6;
      
      // Create the chart
      const chart = new Chart(canvas, {
        type: 'line',
        data: {
          labels: chartData.map(item => item.year.toString()),
          datasets: [{
            label: '数值',
            data: chartData.map(item => item.value),
            borderColor: 'rgb(59, 130, 246)',
            backgroundColor: 'rgba(59, 130, 246, 0.1)',
            tension: 0.1,
            pointRadius: pointRadius,
            pointHoverRadius: pointHoverRadius,
            pointBackgroundColor: 'white',
            pointBorderColor: 'rgb(59, 130, 246)',
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          layout: {
            padding: padding
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.parsed.y}`;
                }
              }
            },
            datalabels: {
              color: '#333',
              anchor: 'end',
              align: 'top',
              offset: isMobile ? 5 : 8,
              font: {
                weight: 'bold',
                size: isMobile ? 10 : 12
              },
              formatter: function(value) {
                return value;
              },
              backgroundColor: 'rgba(255, 255, 255, 0.7)',
              borderRadius: 4,
              padding: {
                top: 2,
                bottom: 2,
                left: 4,
                right: 4
              },
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: false,
              ticks: {
                padding: 10,
                font: {
                  size: isMobile ? 10 : 12
                }
              },
              grid: {
                drawBorder: false,
                borderDash: [5, 5]
              }
            },
            x: {
              ticks: {
                padding: 3,
                font: {
                  size: isMobile ? 10 : 12
                }
              },
              grid: {
                display: true,
                drawBorder: false
              }
            }
          }
        },
        plugins: hasDataLabelsPlugin ? [ChartDataLabels] : []
      });
      
      // Store the chart instance for later cleanup
      chartInstances[canvasId] = chart;
    } catch (error) {
      console.error('Error creating chart:', error, chartKey, canvasId);
    }
  }
</script>

<style is:global>
  .hover-chart-text {
    color: #3570FF;
    text-decoration: underline;
    text-decoration-style: dotted;
    cursor: pointer;
  }
  
  .chart-tooltip {
    padding: 10px 10px 5px 10px;
    min-width: 300px;
    min-height: 200px;
    max-width: 95vw;
    max-height: 70vh;
    transition: width 0.2s ease-in-out, height 0.2s ease-in-out;
  }
  
  .tippy-box[data-theme~='light'] {
    background-color: white;
    color: black;
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    max-width: 95vw !important;
  }
  
  .tippy-box[data-theme~='light'][data-placement^='top'] > .tippy-arrow::before {
    border-top-color: white;
  }
  
  @media (max-width: 768px) {
    .chart-tooltip {
      min-width: 250px;
      padding: 8px 8px 3px 8px;
    }
  }
</style> 